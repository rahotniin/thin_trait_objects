//! This crate provides the `Thin` type, a 1-pointer-wide trait object, used like so:
//!
//! ```
//! use thin_trait_objects::*;
//!
//! #[thin]
//! trait Foo {
//!     fn foo(&self) -> u8;
//! }
//!
//! impl Foo for u8 {
//!     fn foo(&self) -> u8 {
//!         *self
//!     }
//! }
//!
//! fn main() {
//!     let thin = Thin::<dyn Foo>::new(8u8);
//!     // `Foo` is automatically implemented for `Thin<dyn Foo>`
//!     assert_eq!(thin.foo(), 8u8);
//! }
//! ```

use std::marker::PhantomData;

pub use thin_trait_objects_macros::thin;

/// Wraps a pointer to a value of type `Bundle`, generated for each trait by the `#[thin]` attribute:
///
/// ```
/// #[repr(C)]
/// struct Bundle<T: Trait> {
///     vtable: VTable,
///     value: T,
/// }
///
/// #[repr(C)]
/// struct VTable {
///     drop: extern "C" fn(*mut ()),
///     // additional fields...
/// }
/// ```
#[repr(transparent)]
pub struct Thin<T: ?Sized> {
    // type-erased `*mut Bundle`
    ptr: *mut (),
    phantom: PhantomData<T>,
}

/// Helper trait for implementing `Thin::new`.
pub trait IntoThin<T: ?Sized> {
    fn into_thin(self) -> Thin<T>;
}

impl<T: ?Sized> Thin<T> {
    pub unsafe fn from_raw(ptr: *mut ()) -> Thin<T> {
        Thin { ptr, phantom: PhantomData }
    }

    pub fn new<K: IntoThin<T>>(val: K) -> Thin<T> {
        val.into_thin()
    }
}

impl<T: ?Sized> Drop for Thin<T> {
    fn drop(&mut self) {
        // SAFETY: `Bundle` and `VTable` are `#[repr(C)]`,
        // so the `drop` field of `VTable` will be positioned first in the memory layout of `Bundle`
        let dropper: extern "C" fn(*mut ()) = unsafe { *self.ptr.cast() };
        dropper(self.ptr);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use thin_trait_objects_macros::thin;

    #[thin]
    trait Foo {
        fn foo(&self);
        fn bar(&mut self) -> u16;
        fn baz(&mut self, msg: &str);
    }

    impl Foo for u16 {
        fn foo(&self) {
            println!("u16 foo! self: {}", self);
        }
        fn bar(&mut self) -> u16 {
            *self
        }
        fn baz(&mut self, msg: &str) {
            println!("u16 bar! self: {}, msg: {}", self, msg);
        }
    }

    #[test]
    fn one_pointer_wide() {
        assert_eq!(size_of::<Thin<dyn Foo>>(), size_of::<usize>());
    }

    #[test]
    fn it_works() {
        let mut thin = Thin::<dyn Foo>::new(16u16);
        thin.foo();
        assert_eq!(thin.bar(), 16u16);
        thin.baz("hello world");
    }
}

// basis for the design of the #[thin] attribute
mod template_impl {
    use super::*;

    // some attribute to put on your traits
    // #[thin]
    trait Foo {
        fn foo(&self);
        fn bar(&mut self);
    }

    impl Foo for u8 {
        fn foo(&self) {
            println!("u8 foo! self: {}", self);
        }
        fn bar(&mut self) {
            println!("u8 bar! self: {}", self);
        }
    }

    //============================//
    // code generated by the attribute:

    const _: () = {
        #[repr(C)]
        struct VTable {
            // drop MUST be the first field
            // so it can be accessed simply by casting a `VTable` pointer
            drop: extern "C" fn(*mut ()),
            foo:  extern "C" fn(*mut ()),
            bar:  extern "C" fn(*mut ()),
        }

        //=================//
        // these functions are compiled at the source of the thin trait object,
        // and are what get passed around in the vtable

        extern "C" fn drop<T: Foo>(ptr: *mut ()) {
            let bundle = ptr as *mut Bundle<T>;
            // SAFETY: the bundle pointer was obtained using `Box::into_raw`
            let _ = unsafe { Box::from_raw(bundle) };
        }

        extern "C" fn foo<T: Foo>(ptr: *mut ()) {
            let bundle = unsafe { &mut *(ptr as *mut Bundle<T>) };
            T::foo(&mut bundle.val);
        }

        extern "C" fn bar<T: Foo>(ptr: *mut ()) {
            let bundle = unsafe { &mut *(ptr as *mut Bundle<T>) };
            T::bar(&mut bundle.val);
        }

        //=================//

        #[repr(C)]
        struct Bundle<T> {
            // vtable MUST be the first field
            // so the `drop` function pointer can be
            // accessed simply by casting a `Bundle` pointer
            vtable: VTable,
            val: T,
        }

        impl<T: Foo> IntoThin<dyn Foo> for T {
            fn into_thin(self) -> Thin<dyn Foo> {
                let vtable = VTable {
                    drop: drop::<T>,
                    foo:   foo::<T>,
                    bar:   bar::<T>,
                };

                let bundle = Bundle {
                    vtable,
                    val: self,
                };

                let ptr = Box::into_raw(Box::new(bundle)) as *mut ();

                unsafe { Thin::from_raw(ptr) }
            }
        }

        impl Foo for Thin<dyn Foo> {
            fn foo(&self) {
                let vtable = unsafe { &*(self.ptr as *mut VTable) };
                (vtable.foo)(self.ptr)
            }
            fn bar(&mut self) {
                let vtable = unsafe { &*(self.ptr as *mut VTable) };
                (vtable.bar)(self.ptr)
            }
        }
    };
}