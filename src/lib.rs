//! This crate provides the `Thin` type, a 1-pointer-wide trait object, used like so:
//!
//! ```
//! use thin_trait_objects::*;
//!
//! #[thin]
//! trait Foo {
//!     fn foo(&self) -> u8;
//! }
//!
//! impl Foo for u8 {
//!     fn foo(&self) -> u8 {
//!         *self
//!     }
//! }
//!
//! fn main() {
//!     let thin = Thin::<dyn Foo>::new(8u8);
//!     // `Foo` is automatically implemented for `Thin<dyn Foo>`
//!     assert_eq!(thin.foo(), 8u8);
//! }
//! ```

use std::marker::PhantomData;

pub use thin_trait_objects_macros::thin;

/*
    TODO:
     - support for functions that return references
*/


#[repr(transparent)]
pub struct Thin<T: ?Sized> {
    // `T` is always `dyn F` for some trait `F`
    // type-erased `*mut Bundle<K> where `K: F`
    // todo: make private
    pub ptr: *mut (),
    phantom: PhantomData<T>,
}

impl<T: ?Sized> Thin<T> {
    pub unsafe fn from_raw(ptr: *mut ()) -> Thin<T> {
        Thin { ptr, phantom: PhantomData }
    }
}

pub trait ThinExt<T: ?Sized, K> {
    fn new(val: K) -> Thin<T>;
}

impl<T: ?Sized> Drop for Thin<T> {
    fn drop(&mut self) {
        // SAFETY: `Bundle` and `VTable` are `#[repr(C)]`,
        // so the `drop` field of `VTable` will be positioned first in the memory layout of `Bundle`
        let dropper: extern "C" fn(*mut ()) = unsafe { *self.ptr.cast() };
        dropper(self.ptr);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use thin_trait_objects_macros::thin;

    #[thin]
    trait Foo {
        fn foo(&self);
        fn bar(&mut self) -> u16;
        fn baz(&mut self, msg: &str);
    }

    impl Foo for u16 {
        fn foo(&self) {
            println!("u16 foo! self: {}", self);
        }
        fn bar(&mut self) -> u16 {
            *self
        }
        fn baz(&mut self, msg: &str) {
            println!("u16 bar! self: {}, msg: {}", self, msg);
        }
    }

    #[test]
    fn one_pointer_wide() {
        assert_eq!(size_of::<Thin<dyn Foo>>(), size_of::<usize>());
    }

    #[test]
    fn it_works() {
        let mut thin = Thin::<dyn Foo>::new(16u16);
        thin.foo();
        assert_eq!(thin.bar(), 16u16);
        thin.baz("hello world");
    }
}

// example output of the `#[thin]` attribute
mod example_output {
    use super::*;

    // `#[thin]` would go here
    trait Foo {
        fn foo(&self);
        fn bar(&mut self);
        fn add(&mut self, other: u8);
        fn get(&self) -> u8;
    }

    impl Foo for u8 {
        fn foo(&self) {
            println!("u8 foo! self: {}", self);
        }
        fn bar(&mut self) {
            println!("u8 bar! self: {}", self);
        }
        fn add(&mut self, other: u8) {
            *self += other;
        }
        fn get(&self) -> u8 {
            *self
        }
    }

    //============================//
    // code generated by the attribute:

    const _: () = {
        #[repr(C)]
        struct VTable {
            drop: extern "C" fn(*mut ()),
            foo: extern "C" fn(*const ()),
            bar: extern "C" fn(*mut ()),
            add: extern "C" fn(*mut (), u8),
            get: extern "C" fn(*const ()) -> u8,
        }
        #[repr(C)]
        struct Bundle<T: Foo> {
            vtable: VTable,
            value: T,
        }
        extern "C" fn drop<T: Foo>(ptr: *mut ()) {
            let bundle = ptr as *mut Bundle<T>;
            let _ = unsafe { Box::from_raw(bundle) };
        }
        extern "C" fn foo<T: Foo>(ptr: *const ()) {
            let ptr = unsafe { &((*(ptr as *const Bundle<T>)).value) };
            T::foo(ptr)
        }
        extern "C" fn bar<T: Foo>(ptr: *mut ()) {
            let ptr = unsafe { &mut ((*(ptr as *mut Bundle<T>)).value) };
            T::bar(ptr)
        }
        extern "C" fn add<T: Foo>(ptr: *mut (), other: u8) {
            let ptr = unsafe { &mut ((*(ptr as *mut Bundle<T>)).value) };
            T::add(ptr, other)
        }
        extern "C" fn get<T: Foo>(ptr: *const ()) -> u8 {
            let ptr = unsafe { &((*(ptr as *const Bundle<T>)).value) };
            T::get(ptr)
        }
        impl<T: Foo> ThinExt<dyn Foo, T> for Thin<dyn Foo> {
            fn new(value: T) -> Thin<dyn Foo> {
                let vtable = VTable { drop: drop::<T>, foo: foo::<T>, bar: bar::<T>, add: add::<T>, get: get::<T> };
                let bundle = Bundle { vtable, value };
                let ptr = Box::into_raw(Box::new(bundle)) as *mut ();
                unsafe { Thin::from_raw(ptr) }
            }
        }
        impl Foo for Thin<dyn Foo> {
            fn foo(&self) {
                let ptr = self.ptr;
                let shim = {
                    let vtable = unsafe { &*(ptr as *const VTable) };
                    vtable.foo.clone()
                };
                shim(ptr)
            }
            fn bar(&mut self) {
                let ptr = self.ptr;
                let shim = {
                    let vtable = unsafe { &*(ptr as *const VTable) };
                    vtable.bar.clone()
                };
                shim(ptr)
            }
            fn add(&mut self, other: u8) {
                let ptr = self.ptr;
                let shim = {
                    let vtable = unsafe { &*(ptr as *const VTable) };
                    vtable.add.clone()
                };
                shim(ptr, other)
            }
            fn get(&self) -> u8 {
                let ptr = self.ptr;
                let shim = {
                    let vtable = unsafe { &*(ptr as *const VTable) };
                    vtable.get.clone()
                };
                shim(ptr)
            }
        }
    };
}
